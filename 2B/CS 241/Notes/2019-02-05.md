__CS 241__ | February 5, 2019

### Maximal Munch Algorithm

Run DFA (without $\epsilon$-moves) until no non-error move (transition) is available.

1. If in an accepting state, output the found token.

2. Otherwise, if not in an acceptable state (since the next move is an error):

   -  Revert back to the most recent accepting state and output token at that state. This requires the use of a variable to keep track of that state/token.

   - Resume from there.

3. $\epsilon$- move back to the start state.

**Caveats:** However, this can cause a lot of confusion if there is ambiguous input. For example, `a+++b` could be:

1. `a++ + b`
2. `a + ++b`

yet this will always choose option 1. So, if a programmer is unaware of the choices that the tokenizer makes and intends for the code to work like option 2, it can be _extremely hard to spot errors in code._

We look at a simplified version.

### Simplified Maximal Munch

This is the same as MM above, but if not in an accepting state when no transitions are available, produce an `ERROR`.

In practice, this algorithm is good enough, and most languages implement scanning through this method. 

> **Ex.** Prior versions of `C++` would not accept `vector<pair<string, int>>` since it would interpret `>>` as the right bitshift operator instead of closing brackets (you would need `> >` for it to be valid).



# Context Free Grammar

Consider the alphabet of parentheses and a language where all strings are balanced parentheses. Our DFA would be an increasing amount of states, where increasing by 1 state would let us recognize one more level of nested parentheses. This is not a DFA, as we would need an infinite number of states.

So, we move to **Context-Free Languages.** These are languages that _can be described by a Context-Free grammar._

For the problem above:
$$
S \rightarrow \epsilon \\
S \rightarrow ( \ S \ ) \\
S \rightarrow SS
$$




